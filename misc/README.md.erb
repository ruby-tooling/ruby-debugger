[![Ruby](https://github.com/ruby/debug/actions/workflows/ruby.yml/badge.svg?branch=master)](https://github.com/ruby/debug/actions/workflows/ruby.yml?query=branch%3Amaster) [![Protocol](https://github.com/ruby/debug/actions/workflows/protocol.yml/badge.svg)](https://github.com/ruby/debug/actions/workflows/protocol.yml)

# debug.rb

This library provides debugging functionality to Ruby (MRI) 2.6 and later. It has several advantages:

- Fast: No performance penalty on non-stepping mode and non-breakpoints.
- Native remote debugging support:
  - [UNIX domain socket](/docs/remote_debugging.md#unix-domain-socket-uds) (UDS)
  - [TCP/IP](/docs/remote_debugging.md#tcpip)
  - Integration with rich debugger frontends

     Frontend |  [Console](/docs/remote_debugging.md#debugger-console) | [VSCode](/docs/remote_debugging.md#vscode) | [Chrome DevTools](/docs/remote_debugging.md#chrome-devtool-integration) |
     ---|---|---|---|
     Connection | UDS, TCP/IP | UDS, TCP/IP | TCP/IP |
     Requirement | No | [vscode-rdbg](https://marketplace.visualstudio.com/items?itemName=KoichiSasada.vscode-rdbg) | Chrome |
  - See the [remote debugging guide](/docs/remote_debugging.md) for details
- Flexible: Users can use the debugger in multiple ways
  - Through requiring files - like `require "debug"`
  - Through the [`rdbg` executable](#the-rdbg-executable)
  - Through Ruby APIs
  - See [activate the debugger in your program](#activate-the-debugger-in-your-program) for details

# Installation

```
$ gem install debug
```
If you use Bundler, write the following line to your Gemfile.

```rb
gem "debug", ">= 1.6.0"
```

# Usage

The debugger is designed to support a wide range of use cases, so you have many ways to use it.

But a debugging session usually consists of 4 steps:

1. [Activate the debugger in your program](#activate-the-debugger-in-your-program)
1. [Set breakpoints](#set-breakpoints)
    - Through [`binding.break`](#the-bindingbreak-method)
    - Or [breakpoint commands](#breakpoint)
1. Execute/continue your program and wait for it to hit the breakpoints
1. [Start debugging](#start-debugging)
    - Here's the [full command list](#console-commands)
    - You can also type `help` or `help <command>` in the console to see commands

> **Note**
> You can connect the debugger to your program remotely through UNIX socket or TCP/IP.
> To learn more, please check the [remote debugging guide](/docs/remote_debugging.md).

> **Note**
> If you want to use VSCode/Chrome integration, the steps will be slightly different. Please also check their dedicated sections:
> - [VSCode](/docs/remote_debugging.md#vscode)
> - [Chrome DevTools](/docs/remote_debugging.md#chrome-devtool-integration)

## Activate the debugger in your program

As mentioned earlier, you can use various ways to integrate the debugger with your program. Here's a simple breakdown:

Start at program start | `rdbg` | require | debugger API (after `require "debug/session"`)
---|---|---|---|
Yes | `rdbg` | `require "debug/start"` | `DEBUGGER__.start`
No | `rdbg --nonstop` | `require "debug"` | `DEBUGGER__.start(nonstop: true)`

But here are the 2 most common use cases:

### `require "debug"`

Similar to `byebug` or `pry`, once you've required `debug`, you can start setting breakpoints with the [`binding.break`](#the-bindingbreak-method) method.

### The `rdbg` executable

You can also start your program with the `rdbg` executable, which will enter a debugging session at the beginning of your program by default.

```shell
❯ rdbg target.rb
[1, 7] in target.rb
=>   1| def foo # stops at the beginning of the program
     2|   10
     3| end
     4|
     5| foo
     6|
     7| binding.break
=>#0    <main> at target.rb:1
(rdbg)
```

If you don't want to stop your program until it hits a breakpoint, you can use `rdbg --nonstop` instead (or `-n` for short).

```shell
❯ rdbg --nonstop target.rb
[2, 7] in target.rb
     2|   10
     3| end
     4|
     5| foo
     6|
=>   7| binding.break # stops at the first breakpoint
=>#0    <main> at target.rb:7
(rdbg)
```

If you want to run a command written in Ruby like like `rake`, `rails`, `bundle`, `rspec` and so on, you can use `rdbg -c` option.

- Without `-c` option, `rdbg <name>` expects `<name>` to be a Ruby script and invokes it like `ruby <name>` with the debugger.
- With `-c` option, `rdbg -c <name>` expects `<name>` to be a command in `PATH` and simply invoke it with the debugger.

Examples:
- `rdbg target.rb`
- `rdbg -c -- rails server`
- `rdbg -c -- bundle exec ruby foo.rb`
- `rdbg -c -- bundle exec rake test`
- `rdbg -c -- ruby target.rb` is same as `rdbg target.rb`

> **Note**
> `--` is needed to separate the command line options for `rdbg` and invoking command. For example, `rdbg -c rake -T` is recognized like `rdbg -c -T -- rake`. It should be `rdbg -c -- rake -T`.

> **Note**
> If you want to use bundler (`bundle` command), you need to write `gem debug` line in your `Gemfile`.

## Set breakpoints

### The `binding.break` method

`binding.break` (and its aliases `binding.b` and `debugger`) set breakpoints at the written line.

```rb
❯ ruby -rdebug target.rb
[2, 7] in target.rb
     2|   10
     3| end
     4|
     5| foo
     6|
=>   7| binding.break
=>#0    <main> at target.rb:7
(rdbg)
```

#### Advanced usages

- If `do: 'command'` is specified, the debugger will

    1. Stop the program
    1. Run the `command` as a debug command
    1. Continue the program.

    It is useful if you only want to call a debug command and don't want to stop there.

    ```rb
    def initialize
      @a = 1
      binding.b do: 'watch @a'
    end
    ```

    In this case, the debugger will register a watch breakpoint for `@a` and continue to run.

- If `pre: 'command'` is specified, the debugger will
    1. Stop the program
    1. Run the `command` as a debug command
    1. Keep the console open

    It is useful if you have repeated operations to perform before the debugging at the breakpoint

    ```rb
    def foo
      binding.b pre: 'info locals'
      ...
    end
    ```

    In this case, the debugger will display local variable information automatically so you don't need to type it repeatedly.

## Start debugging

Once you're in the debugger console, you can start debugging with it. But here are some useful tips:

- `Enter` without any input repeats the last command (useful when repeating `step`s).
- `Ctrl-D` is the same as the `quit` command.

### Command & expression parsing

Because the debugger supports both Ruby expression evaluation and dozens of commands, name collision happens.

So here're a few rules explaining how the debugger interprets your input:

- If `<input>.split(" ")` does **NOT** start with any debugger command (e.g. `my_var` or `foo bar`), it will be evaluated as `pp <input>`
- If `<input>.split(" ")` starts with a command or a command shortcut (like `info` and `i`), it will be treated as a command instead.

Some examples:

  - `foo.bar` is same as `pp foo.bar`.
  - `info arg` are `i arg` are considered as `<info cmd> arg`
  - `info(arg)` is considered as `pp self.info(arg)`
  - `i` is considered as `<info cmd>`
  - `pp i` prints `i`


### Console commands

You can use the following debug commands. Each command should be written in 1 line.

The `[...]` notation means this part can be eliminated. For example, `s[tep]` means `s` or `step` are both valid commands. `ste` is not valid.
The `<...>` notation means the argument.

Here's a [Google sheet](https://docs.google.com/spreadsheets/d/1TlmmUDsvwK4sSIyoMv-io52BUUz__R5wpu-ComXlsw0/edit?usp=sharing) for comparing this and other Ruby debuggers' commands.

<%= DEBUGGER__.help %>

# Configuration

You can configure the debugger's behavior with the `config` command and environment variables.

Every configuration has a corresponding environment variable, for example:

```
config set log_level INFO # RUBY_DEBUG_LOG_LEVEL=INFO
config set no_color true  # RUBY_DEBUG_NO_COLOR=true
```

<% cat = nil; DEBUGGER__::CONFIG_SET.each do |key, (env, desc, _, default)| %>
<% /\A(\w+): (.+)/ =~ desc; if cat != $1; cat = 1 %>
- <%= $1 %>
<% cat = $1; end %>  - `<%= env %>` (`<%= key %>`): <%= default ? "#{$2} (default: #{default})" : $2 %><% end %>

## Initialization scripts

If you want to run certain commands or set configurations for every debugging session automatically, you can put them into the `~/.rdbgrc` file.

If you want to run additional initial scripts, you can also,

- Use `RUBY_DEBUG_INIT_SCRIPT` environment variable can specify the initial script file.
- Specify the initial script with `rdbg -x initial_script`.

Initial scripts are useful to write your favorite configurations.  For example,

```
config set use_short_path true # Use $(Gem)/gem_content to replace the absolute path of gem files
```

Finally, you can also write the initial script in Ruby with the file name `~/.rdbgrc.rb`.

## rdbg command help

```
<%= `exe/rdbg --help` %>
```

# Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/ruby/debug.
This debugger is not mature so your feedback will help us.

Please also check the [contributing guideline](/CONTRIBUTING.md).

# Acknowledgement

- Some tests are based on [deivid-rodriguez/byebug: Debugging in Ruby 2](https://github.com/deivid-rodriguez/byebug)
- Several codes in `server_cdp.rb` are based on [geoffreylitt/ladybug: Visual Debugger](https://github.com/geoffreylitt/ladybug)
